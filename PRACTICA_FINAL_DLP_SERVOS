library IEEE;

use IEEE.STD_LOGIC_1164.ALL;

use IEEE.NUMERIC_STD.ALL;

entity SERVO_MEMORIA_2SERVOS is

Port (

    CLK       : in  STD_LOGIC;

    RST       : in  STD_LOGIC;

    MODE      : in  STD_LOGIC;  -- 1=escritura, 0=ejecuciÃ³n

    SEL_SERVO : in  STD_LOGIC;  -- 1=Servo1, 0=Servo2



    UP     : in  STD_LOGIC;

    DN     : in  STD_LOGIC;

    RIGHT  : in  STD_LOGIC;

    CENTER : in  STD_LOGIC;



    PWM1_OUT : out STD_LOGIC;

    PWM2_OUT : out STD_LOGIC;



    ANO : out STD_LOGIC_VECTOR(7 downto 0);

    SEG : out STD_LOGIC_VECTOR(7 downto 0)

);

end SERVO_MEMORIA_2SERVOS;

architecture Behavioral of SERVO_MEMORIA_2SERVOS is

constant PWM_PERIOD : integer := 1_000_000;

constant WAIT_1S    : integer := 50_000_000;

constant DEB_MAX    : integer := 50_000;



type mem_array is array (0 to 4) of integer range 0 to 99;



signal mem1, mem2 : mem_array := (others => 0);

signal reg_sel    : integer range 0 to 4 := 0;

signal digit_sel  : std_logic := '0';



signal pwm_cnt : integer range 0 to PWM_PERIOD := 0;

signal pw1, pw2 : integer := 50_000;



signal exec_cnt : integer := 0;



signal refresh : unsigned(15 downto 0) := (others => '0');

signal digit   : unsigned(2 downto 0)  := (others => '0');



signal cu, cd, cr, cc : integer range 0 to DEB_MAX := 0;

signal udb, ddb, rdb, cdb : std_logic := '0';

signal up_p, dn_p, r_p, c_p : std_logic := '0';



function bin7(b : integer range 0 to 9) return STD_LOGIC_VECTOR is

begin

    case b is

        when 0 => return "11000000";

        when 1 => return "11111001";

        when 2 => return "10100100";

        when 3 => return "10110000";

        when 4 => return "10011001";

        when 5 => return "10010010";

        when 6 => return "10000010";

        when 7 => return "11111000";

        when 8 => return "10000000";

        when 9 => return "10010000";

        when others => return "11111111";

    end case;

end function;



function get_tens(v : integer) return integer is

begin

    if v >= 90 then return 9;

    elsif v >= 80 then return 8;

    elsif v >= 70 then return 7;

    elsif v >= 60 then return 6;

    elsif v >= 50 then return 5;

    elsif v >= 40 then return 4;

    elsif v >= 30 then return 3;

    elsif v >= 20 then return 2;

    elsif v >= 10 then return 1;

    else return 0;

    end if;

end function;



function get_units(v : integer) return integer is

begin

    if v >= 90 then return v-90;

    elsif v >= 80 then return v-80;

    elsif v >= 70 then return v-70;

    elsif v >= 60 then return v-60;

    elsif v >= 50 then return v-50;

    elsif v >= 40 then return v-40;

    elsif v >= 30 then return v-30;

    elsif v >= 20 then return v-20;

    elsif v >= 10 then return v-10;

    else return v;

    end if;

end function;

begin

-- ANTIRREBOTE

process(CLK)

    variable lu, ld, lr, lc : std_logic := '0';

begin

    if rising_edge(CLK) then

        if UP='1' then if cu<DEB_MAX then cu<=cu+1; else udb<='1'; end if;

        else cu<=0; udb<='0'; end if;



        if DN='1' then if cd<DEB_MAX then cd<=cd+1; else ddb<='1'; end if;

        else cd<=0; ddb<='0'; end if;



        if RIGHT='1' then if cr<DEB_MAX then cr<=cr+1; else rdb<='1'; end if;

        else cr<=0; rdb<='0'; end if;



        if CENTER='1' then if cc<DEB_MAX then cc<=cc+1; else cdb<='1'; end if;

        else cc<=0; cdb<='0'; end if;



        up_p <= udb and not lu;

        dn_p <= ddb and not ld;

        r_p  <= rdb and not lr;

        c_p  <= cdb and not lc;



        lu:=udb; ld:=ddb; lr:=rdb; lc:=cdb;

    end if;

end process;



-- PWM

process(CLK)

begin

    if rising_edge(CLK) then

        if pwm_cnt<PWM_PERIOD then pwm_cnt<=pwm_cnt+1;

        else pwm_cnt<=0; end if;



        if pwm_cnt < pw1 then PWM1_OUT <= '1';

			else PWM1_OUT <= '0'; end if;

			

			if pwm_cnt < pw2 then PWM2_OUT <= '1';

			else PWM2_OUT <= '0'; end if;

    end if;

end process;



-- CONTROL

process(CLK)

    variable val : integer;

begin

    if rising_edge(CLK) then

        if RST='1' then

            mem1 <= (others=>0);

            mem2 <= (others=>0);

            reg_sel <= 0;

            digit_sel <= '0';

            exec_cnt <= 0;

        else

            if MODE='1' then

                if c_p='1' then

                    if reg_sel=4 then reg_sel<=0; else reg_sel<=reg_sel+1; end if;

                end if;



                if r_p='1' then digit_sel<=not digit_sel; end if;



                if SEL_SERVO='1' then val:=mem1(reg_sel);

                else val:=mem2(reg_sel); end if;



                if up_p='1' then

                    if digit_sel='0' and val<=89 then val:=val+10;

                    elsif digit_sel='1' and get_units(val)<9 then val:=val+1; end if;

                elsif dn_p='1' then

                    if digit_sel='0' and val>=10 then val:=val-10;

                    elsif digit_sel='1' and get_units(val)>0 then val:=val-1; end if;

                end if;



                if SEL_SERVO='1' then mem1(reg_sel)<=val;

                else mem2(reg_sel)<=val; end if;



            else

                if exec_cnt<WAIT_1S then exec_cnt<=exec_cnt+1;

                else

                    exec_cnt<=0;

                    if reg_sel=4 then reg_sel<=0; else reg_sel<=reg_sel+1; end if;

                end if;

            end if;

        end if;



        pw1 <= 50_000 + mem1(reg_sel)*278;

        pw2 <= 50_000 + mem2(reg_sel)*278;

    end if;

end process;



-- MULTIPLEX

process(CLK)

begin

    if rising_edge(CLK) then

        refresh<=refresh+1;

        if refresh=x"FFFF" then digit<=digit+1; end if;

    end if;

end process;



process(digit)

begin

    case digit is

        when "000" => ANO<="11111110"; SEG<=bin7(1);

        when "001" => ANO<="11111101"; SEG<=bin7(reg_sel+1);

        when "010" => ANO<="11111011"; SEG<=bin7(get_tens(mem1(reg_sel)));

        when "011" => ANO<="11110111"; SEG<=bin7(get_units(mem1(reg_sel)));

        when "100" => ANO<="11101111"; SEG<=bin7(2);

        when "101" => ANO<="11011111"; SEG<=bin7(reg_sel+1);

        when "110" => ANO<="10111111"; SEG<=bin7(get_tens(mem2(reg_sel)));

        when "111" => ANO<="01111111"; SEG<=bin7(get_units(mem2(reg_sel)));

        when others => ANO<="11111111"; SEG<="11111111";

    end case;

end process;

end Behavioral;